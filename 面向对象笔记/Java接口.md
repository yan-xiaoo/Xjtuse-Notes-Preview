# 接口（Interface）

## 什么是接口？

在 Java 当中，你可以自定义的数据类型只有两种：**类**和**接口**。类之前已经讲解过，接口将在这里说明。**类就像一个你自己的数据类型**，和任何 Java 语言提供的引用数据类型类似。

接口属于**抽象数据类型**（Abstract data type, ADT）。它把多个类**共同的行为**聚集在一起。它是最高一层的抽象。

> 对象是现实世界中内容在特定应用领域下的抽象：仅保留现实世界对象在目前应用领域的数据和行为
>
> 比如：在「教学系统」方面，一个人穿的衣服，身体状况都不重要。ta的学号，姓名，成绩才是应当关注的地方，因此，他的数据可能仅包含学号，姓名，成绩这些信息。
>
> 类是对多个具有相同的数据和行为的对象抽象。比如，很多学生可以抽象为一个学生类：因为这些学生对象的数据构成和行为类似（比如都有学号，姓名，成绩，虽然每个人的这三个属性不同，但这无所谓）。
>
> 接口是多个行为相同的类的抽象。比如，足球，篮球，坏了的机器都可以被踢，它们可以都有一个”被踢“的方法。这个方法就可以被写在一个单独接口里，然后被上述每个类继承。类需要实现它继承的接口。

接口和类之间是一种「合同」的关系。类继承一个接口之后，必须「保证」其会实现接口中的所有方法。接口自己就像只提要求的甲方，自己不需要实现任何方法，只需要声明方法；继承它的类就像乙方，需要完成所有接口中声明的方法。

由于接口不需要自己实现自己的方法，因此，在 Java 中，规定接口的方法在未特别声明时**全部为 abstract 方法**，即使这些方法没有被直接用 abstract 修饰。

```java
public interface File{
    public void open(String name);
    public void close();
}
```

即使上面这个例子中的两个方法没有被加 `abstract` ，它也是抽象方法。

### 实现接口

上面说过，继承接口的类需要实现接口规定的所有方法；接口本身不实现自己规定的任何方法。比如：

```java
public class TextFile implements File{
    // 以下两个方法是 File 接口要求实现的
    public void open(String name){  
    }
    public void close(){
    }
    // 以下两个方法是自己定义的，不属于 File 接口
    public Byte read(){
    }
    public boolean write(Object obj){
    }
}
```

如果继承接口的类没有实现接口的所有方法，那么**这个类会成为抽象类**（因为包含未实现的抽象方法），你必须手动将此类声明为 `abstract` 类，否则将会编译出错。

一个类可以既继承其他类，又实现接口。此外，一个类可以实现很多接口。

子类会自动实现父类已经实现的接口。

**标记接口**

有些接口没有任何的方法：这意味着实现这个接口的类不需要实现任何的方法。

这种接口一般用来做**标记**，比如，告诉 Java 自己满足某些可选协议的要求。

比如：`Cloneable` 接口用来告诉 Java 这个类的对象可以被克隆。你在实现 `Cloneable` 时，不需要做任何事情。JVM 会在需要时允许通过 `clone()` 方法对这个类的对象做克隆。

为什么不允许所有对象都可复制呢？因为有的对象包含的数据不能被复制，比如文件描述符啥的。因此，在未实现 `Cloneable` 接口时，Java 默认你的类产生的对象不能被复制。

### 变量类型与接口：鸭子类型

一个接口不能直接被实例化，即不能产生「接口类型的对象」。因此，永远**不能使用 new 语句得到接口类型的对象**。

但是，一个接口类型的变量可以指向**任何实现了该接口的类的对象**。比如，请回顾上面提到的 `File` 与 `TextFile` 的定义：

```java
File f = new File(); // 编译出错：不能创建接口类型的对象。
File r = new TextFile(); // 正确：接口类型的变量可以指向实现了该接口的对象
```

此时，这个接口类型的变量**只能调用接口中声明的方法**。比如：

```java
r.open(); // 正确：open 方法是接口中声明的
r.read(); // 错误：read 方法在 TextFile 类中定义，但并不在接口当中声明
```

这种语法有什么用呢？

假如你要对整数做一个冒泡排序。显然，这很简单：

```java
void bubbleSort(int[] items){
    for (int i=0;i<items.length();i++){
        for (int j=0;i<items.length()-i-1;j++){
            if (items[i] < items[j]){
                int temp = items[i];
                items[i] = items[j];
                items[j] = temp;
            }
        }
    }
}
```

然后，你的老板又让你实现一个浮点数的冒泡排序，还行吧：

```java
void bubbleSort(float[] items){
    for (int i=0;i<items.length();i++){
        for (int j=0;i<items.length()-i-1;j++){
            if (items[i] < items[j]){
                float temp = items[i];
                items[i] = items[j];
                items[j] = temp;
            }
        }
    }
}
```

接着，老板又想让你对一个自定义数据类型 Car，关于它的`getYear`方法得到的结果排序。也不是不行……

```java
void bubbleSort(Car[] items){
    for (int i=0;i<items.length();i++){
        for (int j=0;i<items.length()-i-1;j++){
            if (items[i].getYear() < items[j].getYear()){
                Car temp = items[i];
                items[i] = items[j];
                items[j] = temp;
            }
        }
    }
}
```

最过分的来了，老板让你对任何一个自定义的数据类型都实现冒泡排序！难道你要为 Java 已经存在且将来加入的所有类型都写一份冒泡排序吗？不不不，就算你真的写出来了，其他人看见你的代码也会气的半死。其实，只需要定义一个接口，然后让所有需要被排序的类自己实现这个接口。你需要的接口已经在 Java 中定义了，叫做 `Comparable`

```java
// Comparable 的定义大概如下
public interface Comparable{
    // 在自己“小于”另一个对象时返回 -1，“大于”时返回 1，“等于”时返回 0
    int compareTo(Object o);
}

void bubbleSort(Comparable[] items){
    for (int i=0;i<items.length();i++){
        for (int j=0;i<items.length()-i-1;j++){
            if (items[i].compareTo(items[j]) == -1){
                Comparable temp = items[i];
                items[i] = items[j];
                items[j] = temp;
            }
        }
    }
}
```

可以看到，你不需要知道具体想被排序的东西是什么；你只需要知道**它有一个 compareTo 方法可以返回它和另一个同类型对象谁大**。这种「我不关心对象是什么类型，只关心对象有什么行为」的想法，与面向对象的一个思想实例，叫「鸭子类型」，非常类似。

「鸭子类型」是一个面向对象里的思想：如果一个东西长得像鸭子，像鸭子一样叫，那我认为它就是鸭子。其实，如果我只需要知道一个东西会不会鸭子叫的话，我**不需要关心它到底是不是鸭子**（对象是什么类型），只需要**关心它会不会鸭子叫**（对象可以做的行为）。实际上，这个东西可以是鸭子，鹅，鸡或者人，但我不关心它是什么，只关心它会不会鸭子叫。

从上面的例子里可以看到，接口主要是**方便了其他函数对使用接口类的使用**。接口类自身并没简单多少（甚至因为继承了接口而需要多定义一堆方法）

### 子接口：接口的“继承”？

接口可以”继承“其他的接口，效果为：把其他接口中已经声明的方法复制到自己这里来。

接口在继承时同样使用 `extends` 关键字，但是，接口并不限制继承数量。一个接口**可以无限制的继承其他接口**。

### 使用接口：跨层多态

在上面的实例里头可以看到，`bubbleSort` 方法可以传入任何实现了 `Comparable` 接口的对象。不管这个对象所在类有没有关系，只要它们实现了同一个接口，那就可以被用一样的方法使用。这就是**跨层多态**：不需要关注类之间的继承关系，任何实现接口的类都被一视同仁，都可以在方法中使用。

### 接口的命名规范

**"able" 命名法**

为一个功能加上-able后缀，组成一个形容词，作为接口名称。比如，Comparable, Serializable, Cloneable。

**“Impl”命名法**

为一个接口取一个名词性的名字，然后为实现它的类加后缀"-Impl"。比如：

`interface BankAccount` -- `class BankAccountImpl`

**"I" 命名法**

为一个**类**取一个名词名字，然后为其对应的接口加**前缀**“I“。比如：

`interface IBankAccount` -- `class BankAccount`

一般最常用的是第一种方法。