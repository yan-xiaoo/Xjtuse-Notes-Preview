# Java语法（第一部分）

## 学习内容

- Java中变量、函数，类名等命名的约定
- 如何使用一个标识符
- 学习Java的基本数据类型
- 如何声明和初始化Java的变量和数组
- 学习Java的保留关键字

## 标识符

标识符是用来给很多东西起名字用的

Java的标识符可以使用 **英文字母**，**数字**，`_`和`$`这些字符。数字不能作为标识符的开头。

> 和其他语言相比比较特别的就是Java可以使用 `$` 这个字符
>
> 经过测试，这个字符可以用在标识符的任何一个位置。

### 标识符命名建议

- **包名：全小写**
- 类：驼峰命名（每个单词首字母大写）
- **方法：小驼峰（除了第一个单词首字母小写，其他的都大写）**
- 常量：全大写，每个单词中间用下划线连接

## 保留字

『字面值』保留字：**null** **true** **false**

语句中的关键字：一大堆

特殊的：**goto** ：虽然这玩意不是个关键字，但 Java 不让你用它做变量名

# 数据类型

## 基础类型（原始数据类型）

写法：包装数据类型  原始类型

- Integer int
- Float float
- Character char
- Boolean bool

### Integer

包含四种：`byte`, `short`, `int`, `long`：

1字节，2字节，4字节，8字节。

- Java的所有整数**全都带符号**，**没有无符号整数**

- 每个整数都被默认初始化为0

### Float

包含`float` , `double` 两种类型。

- 浮点数**默认初始化为0**

### Character

**Java 的 char 占用两个字节，因为它能表示所有 Unicode 码**

char 只能存放一个 Unicode 字符。内部上，它的取值范围相当于 unsigned short ，取值 0 ～ 65535 (`\u0000` ~ `\uFFFF`)

char 默认初始化为 `\u0`

### Boolean

布尔类型不能用 0 或者 1 交叉赋值。布尔类型只能取 true 或者 false

布尔类型默认初始化为 false

## 引用类型（以数组为例子）

1.  `class` , `interface`
2.  数组数据类型

每个变量必须对应一个数据类型

- 基本数据类型：

  只包含一个值（单值数据类型）

  数据的存放方式和读取时的处理取决于其类型。举个例子，浮点数的存储非常复杂，需要存储一个小数和一个十的幂次；整数只需要直接把二进制转化成十进制就行了

### 定义时：

数组的大小必须是确定的：在被声明之后，无法修改数组的大小。

在定义的时候，以下两种写法都是可以的，看个人习惯：

```java
float a[];
float[] a;
```

但是以下这么写不行：

```java
float a[5];
```

### 初始化时：

数组可以使用常量、表达式或者一个语法糖初始化（大括号初始化：`int a[] = {1, 2, 3, 4, 5};`）

使用 new 关键字创建的数组也可以不初始化。Java 会根据该数组的类型给数组中的所有元素赋个初始值。

数组的下标从0开始。

### 定义和初始化怎么区分？

```java
float a[]; // 芝士定义
a = new float [5]; // 芝士初始化
```

### 部分问题

1. 以下情况为“定义与初始化一体”

   ```java
   float a[] = new float[5];
   ```

   此时：=前面为定义部分，后面为初始化部分。

   永远记住：定义部分不能写数组长度，即这样是不行的：

   ```java
   float a[5] = new float[5];
   ```

   此外，使用 new 时，如果用一个数组字面值给其赋值，则 new 后面也不能写数组长度

   ```java
   float a[] = new float[5]{1,2,3,4,5};
   ```

   是错误的。

   ```java
   float a[] = new float[]{1,2,3,4,5};
   // 或者
   float a[] = new float[5];
   ```
   
   才是正确的。
   
   也就是说，使用 new 创建数组的时候，**数组的初始值设定**和**数组的长度**只能选一个给出

### 数组的空间占用是怎么样的？

在 `float a[];` 这里定义时，Java 只会在栈区创建一个对应数据类型数组的变量；这个变量占用四个字节。

> 所有的引用类型在定义的时候（不使用 new ）的情况下只会在栈区创建一个4字节（也可能是8字节，如果系统给你的地址空间标号比4.2GB还大的情况下……）的变量。

在 `new float[5];` 时：你申请在堆区创建一个数组对象。

new 操作符有三个功能：**在堆区分配你需要的空间；对这个空间按照它的数据类型进行初始化；完成上面两个操作之后，返回分配出的空间的首地址**。

这个对象大小有 4 * 5 = 20 个字节（4 字节一个 float * 5个 float）。由于 float 被初始化为 0.0 ，数组里面的每个 float 全部被初始化为 0.0 。创建完成后，new 表达式返回这个新对象的首地址。

在 `a = ******` 这一块（即赋值的部分），a 被赋值为了该数组（堆区的）首地址。

也就是说：

一个数组**在栈区固定占用几字节空间，用于存储数组自身的位置**；

数组自身**位于堆区，大小取决于数据类型和你让它多长**

可以看成一个“**标头**“和”**真正空间**"两部分。

## 栈区和堆区：空间管理特点

### 栈：

变量在其所在的作用域结束时（比如离开 for, while 语句，函数结束执行时），生命周期结束。

在每个栈区的变量的生命周期结束后，该变量的空间被自动释放。

### 堆：

堆区的变量即使在其生命周期结束之后，也不会被释放。

关于堆区内存的管理，C++，C 和 Java 有两种不同的态度：

**C** 或 **C++**

你的堆区变量占的空间除非被 `free` 或者 `delete` ，否则永远不会被清除。

（当然，你的程序退出的时，操作系统会清理掉你没释放的烂摊子变量）

**Java**

因为 Java 有垃圾回收，jvm 会周期性的释放堆区没有被引用的变量，所以你不需要主动释放堆区的空间。

## 字面值

Java 当中只有 6 种类型可以写字面值：

integer: (int)  `7`

如果想让整数字面值被 Java 认定为 long ，需要加上`L` (`7L`)。

不同进制数字面值的表示：

- 八进制：**0**32，以 0 打头
- 十六进制：**0x**32，以 0x 开头
- 没有二进制的字面值表示。

floating point: (float, double) `7.3` 或者 `7.3f`

> Java 默认浮点数字面值会被当成 double 。要想让 Java 把它视为 float ，需要写 7.3f

boolean : true 或者 false

character:（被当成 char ）

String : "你还" 这样双引号扩起来的

null: 和 None 差不多

注：Java 中的转义字符全是2字节的（因为 Java 的所有字符型都支持 Unicode ，转义字符也不例外）

（很可惜，Java 没有用 utf-8 或者 utf-16 之类的东西减少空间占用）

## Java 类型转换

Java 是一个严格类型的语言（和 Python 一样）

JVM 只能自动的把窄类型向宽类型转换。比如，byte -> short -> int -> long 这种从低到高的转换是可以的。

long -> int 这种转换是无法自动进行的。

> 这和 C 的做法一样

从宽类型转换为窄类型时，必须进行显式转换（强制类型转换）。

**short 和 char 不能直接转换**，因为虽然二者的长度相同，但 short 有符号， char 无符号。

> 强行转换 char 到 short 时，如果 char > 65535 / 2 ，那么 short 会溢出，导致其内容变成一个负数。

## 数据的声明和初始化

- 所有变量在使用前都必须要声明
- 对于基础类型（不包含数组啥），必须要初始化变量后才能使用
- 对于引用类型，变量不初始化也可以用

初始化：用赋值运算符（=）给变量一个值。

## 注释

1. 单行注释：`// ……`

2. 多行注释：

   ```java
   /* dasdad
   adw
   fsfd */
   ```

3. Java Doc注释（可以把这种注释使用javadoc转换为文档）

   ```java
   /** djawkjda
   adwkkd
   awdllkdwladkwkd */
   ```

   

# 操作符

运算顺序：

对象操作（与后加运算符）：`[] . X++ X--`

前置操作：`++x --x ~ !`

> ~ : 按位取反
>
> !：逻辑取否

对象创建和转换：`new (cast)x`

乘除法：`* / % `

加减：`+ -`

移位：`<< >> >>>`

关系运算：`<= >= < > instanceof`

相等：`== !=`

按位与：`&`

按位异或：`^`

按位或：`|`

按逻辑与：`&&`

按逻辑或：`||`

> 短路行为以及如何避免：
>
> 对于 && 来说，如果第一个表达式为假，第二个不会被执行；
>
> 对于 || 来说，如果第一个表达式为真，第二个不会计算；
>
> 使用 & 代替 && 的话，左右两个表达式都会被计算，然后得到逻辑与的结果。

三元运算符：`a ? b : c`

赋值：`= += -= *= /= ……`

# 其他: 关于 Java 的溢出

整型在溢出时会直接变成可表示范围内的值。比如，2147483648 （int 最大为 2147483647）会变成 -2147483648。

浮点数溢出时不会变成范围内的值，而是会变成 `infinity`。比如，

```java
double a = Double.MAX_VALUE;
System.out.println(a * 10);
```

得到结果为 `Infinity`。如果乘 -10 ,会得到 `-Infinity`。

浮点运算中，一个非零的数除零同样会得到`Infinity`

+0.0 和 -0.0 在 Java 里被认为是相等的；但 1.0 / +0.0 和 1.0 / -0.0 一个等于正无穷，一个等于负无穷。

```java
jshell> 1.0 / +0.0
$7 ==> Infinity

jshell> 1.0 / -0.0
$8 ==> -Infinity
```

但正无穷和负无穷不相等：

```java
jshell> 1.0 / +0.0 == 1.0 / - 0.0
$9 ==> false
```

Java，很神奇吧（



如果对整数除零，会出现异常；如果浮点零除零（0.0/0.0），会得到 `NaN` 。这是`Double`类下的一个特殊变量，意思是“Not a Number"，表示不是数的东西。`NaN` 和所有东西的 `==` 运算都是 false， 包括他自己。也就是说：

```java
double a = 1.0 / 0.0;
System.out.println(a == Double.NaN);
```

会得到 false ，也就是 `NaN != NaN` 。

Java 的浮点数有一个问题和其他所有语言一样：不能精确的表示浮点数。比如经典的

`0.1 + 0.2 = 0.30000000000000004`。

```java
jshell> 0.1 + 0.2 == 0.30000000000000004
$2 ==> true

jshell> 0.1 + 0.2 == 0.3
$3 ==> false
```

这是计算机存储浮点数的问题，Java 不背这锅。