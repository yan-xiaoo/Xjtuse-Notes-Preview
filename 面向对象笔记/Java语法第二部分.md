# Java 语法（第二部分）

## 对象与消息

前面有提到，对象通过消息相互沟通。一条消息需要有一个**接受者**和**消息内容**。在以下的语句中：

```java
name.substring(2, 9);
```

`name`是消息的接受者（对象）；`.`选择符表示想给对象发送消息。`substring`表示消息的内容；`(2,9)`也是消息的内容（Java里叫参数）。

给类而不是对象调用时（比如 `Math.min` 时），这种调用不被看成是给对象发送了消息。其实这只是调用了一个静态函数。

> Java 里头由于不允许在类外写代码，而且一个文件只能包含一个 public 类，因此，类还承担了“许多相似功能的集合体”这种作用。比如，Java 中的 Math 类包含 Math.max, Math.min 这些很多静态方法，它实际上是个和数学有关函数的集合体。（所以不用实例化）
>
> 在其他可以在类外定义函数的语言，比如 Python 中，就不需要把很多功能集合到类里了，直接在文件里定义很多函数即可。

**如何判断一个调用是给对象发送消息还是调用类的静态函数？**（即，调用的函数是不是 static 函数？）

如果一个调用是给对象发送消息，它的返回结果**和对象自己的数据有关**。比如，每个学生都有个 getName 方法，调用 `student.getName()`时，返回的名字**取决于每个学生对象的 name 属性**。不同对象调用时结果不同。

而对于 `Math.min` 这种函数，它返回的结果仅仅取决于你输入的内容，因此它是 static 函数。

## 引用类型的声明与初始化

声明时需要写出该变量的数据类型（类）

使用 `=` 进行初始化的操作；使用 `new` 操作符创建新的对象，然后赋值给变量。

引用类型 的变量的初始值为 **null** 。（回忆：int 的默认值为 0，char 的默认值为 '\u0000'）。

所有的引用类型在栈区占用空间都是4字节（如果你用64位机的话，可能是8字节），因为引用类型在栈区存放的东西全都是一样的，都是地址。

**引用类型的数组和基础类型的数组初始化的不同**

虽然引用类型的数组和基础类型的数组都是引用类型，但它们在初始化时行为不同。基础类型的数组的初始化之前已经提到过，不再写一次了。

对于引用类型的数组的初始化（使用二级指针）：假设有一个引用类型 Student

```java
public class Student{
    int age;
    double score;
    String toString(){
        // 假装这里有代码
    }
}
```

然后，使用以下语句初始化这个类型：

```java
Student student[] = new Student[3];
```

这一步完成之后，堆区会被创建一个 3块 x 每块4字节 的空间，每块都用来**存放指针**，会被初始化为 null。

注意：这时这三个对象**并不真实存在**；堆区**尚不存在三个 Student 对象**。不管引用类型是什么，只要是引用类型的数组，创建的一块内容就是4字节（指针大小）。在这三个对象没有被分别初始化前，**每个指针都指向null**

详细点说，看看这个例子：

```java
Student student[] = new Student[3];
student[0].toString(); // NullPointerException，因为student里每个位置的指针都指向null。
```

接着，可以使用以下语句初始化这三个对象中的每一个：

```java
student[0] = new Student();
student[1] = new Student();
student[2] = new Student();
```

这时，堆区创建了三个对象，**这些对象的大小取决于对象里数据的大小**。在这里，每个对象中包含一个 int，一个double，故**每个对象大小为12**。

堆区那块3x4的空间中，**每个空间中的指针现在存放了这三个刚出现的对象的地址**。也就是说，现在这个数组里的三个对象**都真实存在了**，使用时也不会出 `NullPointerException` 了。

在向对象发送消息时，**该对象必须是真实的**，也就是说，已经在堆区存在了。如果只创建一个数组，而不初始化数组里的每一个量，那这个数组里的对象就**不是真实存在的**。

## 在引用类型中的`==` 运算符

在引用类型中，`==`运算符检查的是**两个变量存放的指向对象指针是否指向同一个对象**

```java
Test a = new Test(1);
Test b = new Test(1);
// a 和 b 不指向同一个对象，因此 == 判断它们并不相同
a == b; // false

Test a = new Test(1);
Test b = a;
// a 和 b 指向了同一个对象，== 认为它们相同
a == b; // true
```

如果想判断两个变量指向的对象中某些数据一不一样，而不是这两个变量是否指向同一个对象，可以在类中定义`equals`方法，调用 `a.equals(b)` 之类的方法来比较数据是否一致。

这种情况**只在引用类型下适用**。`==` 运算符可以很好的比较**基础类型**的变量是否相等。

> Python 里是怎么做的？
>
> Python 用 is 关键字检查地址是否一致（就是 `id(a) == id(b)`），== 运算符用来判断数据是否相等。Python 里可以通过重写魔法方法`__eq__`来使得该类型能够使用 == 运算符。（如果不定义  `__eq__`的话，== 运算符对你的对象相当于 is 关键字，只检查地址是否一致。)

## 包装类

八个基础数据类型中，每一个**都有一个对应包装类**。包装类属于引用类型，为每个基础数据类型提供了额外的能力。比如说，`Double.parseDouble` 让你可以把字符串中的数字转换为真正的浮点数；`Integer.toHexString` 可以让你把一个整数转换成一个包含16进制数的字符串。

包装类和基础数据类型的对应关系：

| 基础类型 | 包装类型 |
| -------- | -------- |
| int      | Integer  |
| float    | Float    |
| double   | Double   |
| short    | Short    |
| byte     | Byte     |
| long     | Long     |
| char []  | String   |

（某种程度上，char [] 和 String大概算是基础类型和包装类型的关系…吧……）

## String 类型

String 虽然是个引用类型，但它非常特别；它拥有很多其他引用类型绝不可能有的特性。

1. 初始化的特殊性：String 可以使用一个字符串常量初始化；其他引用类型几乎只能使用 new 关键字创建。

   ```java
   String a = "This is a string"; // 可以
   String a = new String("This is a string"); // 可以
   
   Test a = "A test"; // 绝对不行
   Test a = new Test("A test"); // 可以
   ```

2. String 可以使用+运算符，代表连接字符串；其他引用类型都不行。

   ```java
   String a = "This i" + "s a s" + "tring"; // This is a string
   ```

   此外，**其他基本数据类型和 String 的+运算会被视为连接字符串**

   ```java
   String a = "Result = " + 1 + 2 + 3; // 先把1，2，3转换成字符串，再连接字符串
   System.out.println(a); // Result = 123
   ```

   不过，String 是个不可变对象：任何对 String 的连接操作都会创建一个新的字符串对象。大量连接字符串时，堆里会产生一大堆没用的中间字符串，十分的烦人；所以大量连接字符串时尽量别用+做连接运算。

String 初始化的方法：

- 直接使用一个 `new String("一些字符串")`
- 使用 `String.valueOf()` 传入一个可以转换为 String 的参数
- 直接为 String 赋值一个字符串字面值（注意：这在引用类型里只有 String 能做到）

String 是一个常量，上面提到过。也就是说，任何对 String 的“修改“式操作都会变成创建一个新的字符串。

由于这个特点，字符串的指针可以**直接指向常量区的某个字符串常量**。并且，一般来说，初始化字符串的时候，字符串就是指向堆区的。如：

```java
String a = "Hello world!";
// Hello world 由于是个字符串字面值常量，被扔到了常量区。并没有复制一遍再在堆上开一个空间。
// 对 a 修改时，常量区的 “Hello world” 不会变化；而是会产生一个新的字符串j，
```

字符串的相等比较：由于字符串一般指向常量区，且Java为了节省空间会对内容相同的字符串指向同一块常量区，因此 `==` 操作符偶尔可以用来比较相不相同。

> 回忆一下：== 检查地址是否一样；.euqals 方法检查对象内容是否一样

当然，字符串也可以在堆上创建：使用 new 关键字即可。这样的字符串即使内容一致，也不可能用 == 比较内容。

总而言之，`==` 操作符对字符串不稳定：字符串指向常量区时可以用；指向堆上时不能用。因此，不要用 `==` 操作符判断字符串内容是否一致。

````java
String a = "hello";
String b = "hello";
a == b; // true

// 堆上的字符串
String a = new String("Hello");
String b = new String("Hello");
a == b; // false
````

### String 的构建：`StringBuffer`

（总感觉这东西的API和Python的列表差不多）

`StringBuffer` 是一个用来修改，拼接字符串用的类。字符串类型由于不可变，直接使用 + 连接字符串的话，会出现一大堆的垃圾字串，而且速度也很慢。因此，就像Python里用 `"".join([Iterable])`来连接字符串一样，Java 也有它的字符串拼接类。

`StringBuffer` 虽然在初始化的时候需要指定大小，但其实它可以无限扩大。所以，开始的时候指定多大都无所谓。

`StringBuffer` 主要有两个方法：`append` 方法和 `insert` 方法。

`append(value)` ：在一个 `StringBuffer` 对象的最后添加一个字符或者字符串（有一个字符的重载和字符串的重载）

`insert(position, value)`：在 position 位置插入 value。插入的东西可以是字符或者字符串。

`toString()` ：把 `StringBuffer` 里的东西转换成 `String`

StringBuffer 是线程安全的，但是速度更慢一点；StringBuilder 的速度较快，但在多线程下不安全。

## 条件语句：if - else

条件里面的内容必须是一个可以转换为 `bool` 的东西，比如 `x > 1` 这样的。

### 三元运算符： `if-else` 的简化

`a ? b : c`

如果 a 为真，那么执行 b ，否则执行 c。

> 可以看成 a 是一个问题，问号是在问：它对不对呀？对的话执行 b ，不对的话选 c

## switch 语句

Java 的 switch 语句和 C 的完全一样：

```java
switch (a){
    case 1:
        xxx;
        break;
    case 2:
        xxx;
    default:
        xxx;
}
```

注意：所有像 case 2 这样没加 break 的语句会使得下面的所有 case 全都被执行。这一般是你不希望看到的，不过也不一定（）

default 会在其他子句都没匹配的时候被调用。

## for 与 while 语句

与 C 中的完全一样，没有任何需要注意的地方。

### break 与 continue

Java 的特殊语法现象：**你可以给一个循环加标签**

```java
outer: for (int i = 0; i< 5; i++){
    inner: for (int j=0; j<5;j++){
        
    }
}
```

然后可以在 continue 与 for 语句后边加参数以决定**在多层循环中要跳出到哪里**

```java
int sum = 0;
outer: for (int i = 0; i< 5; i++){
    inner: for (int j=0; j<5;j++){
        sum++;
        if (j == 2){
            continue outer; // 中止本次 outer 循环的执行，直接回到 outer 内的起点再执行
        }
        if (j == 1){
            continue // 仅中止本次 inner 的循环，并进行下次
        }
        if (j == 4){
            break outer; // 直接跳出 outer，即跳出了所有循环
        }
        if (j == 3){
            break; // 仅仅跳出 inner 循环，outer循环还需要进行。
        }
    }
}
```

这在某种程度上起到了`goto`语句离开多层循环的作用。

注：有的时候，`continue outer `（执行下一轮外循环）可以看做 `break` （结束内循环）

（这仅仅在内循环结束之后，外循环没有其他语句时才成立）

> ps: 上述代码中的 sum 在最后的值为15。因为对于 i =0~4，这五次循环时，每次j=0啥都不触发，j=1触发内层 continue，j=2触发外层 continue结束内循环。所以5次循环内，每一次sum都加了3次。

## for 和 while：选择哪个？

这两个语句每一个都可以改写成另一个。我倾向于认为 for 是 while 的语法糖。比如：

```java
for (int a = 0; a < 10; a++){
    b++;
}
```

相当于：

```java
int a = 0;
while (a < 10){
    b++;
    a++;
}
```

一般来说，二者可以互通。不过，以下情况下最好选择对应的语句：

- 只有满足某个条件才结束的循环（不知道循环次数）： while
- 循环指定的次数： for

## return 语句

`return` 语句用来返回你函数开头声明的返回值那种对象。如果返回值类型为`void`，则你只需要无参数的使用 `return` 语句（或者压根不加 return）。如果返回值不是 `void`，那你需要：

返回一个和声明的返回值**兼容**的类型的东西。

> 兼容：如果你声明的返回值的类型是实际返回值类型的宽类型，则称你声明的返回值的类型兼容你实际的返回值的类型。
>
> 也就是说，你实际返回的东西可以是你声明返回的东西的更窄类型
>
> 比如，double 兼容 float；int 兼容 short；对于父类和子类，父类类型兼容子类类型。
>
> （本质就是你实际返回的东西需要**能通过隐式类型转换**变成声明的返回值的类型。

注：父类相对于其子类是宽类型。

声明为返回父类类型的函数可以实际返回一个子类类型对象。