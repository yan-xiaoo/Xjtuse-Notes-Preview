# Java 例外与例外处理

## 什么是例外？

什么是例外？程序运行的时候发生了一些「意料之外的事情」，导致程序的运行条件不能满足/执行出现错误，无法继续执行下去，就称为发生了例外。

例外有很多的种类：

有的例外是程序员在设计程序时就可以避免的，比如错误的计算了 2/0；这种错误可以通过程序员的检查等避免，比如时刻检查除数不是0。

还有些例外无法避免。比如，一个程序需要读取某个文件，但这个文件可能被用户误删除了；程序员无法预见用户会乱删文件，因此也无法避免这个问题的发生。因此，这种例外是无法避免的。

例外并不等于「一切都搞砸了」。有的程序可以把例外作为一个信号（比如在银行取钱时，如果余额不足取出的钱，程序可能会主动抛出一个例外，打断流程的执行）。

这些例外的共性是：**会打断程序正常执行的流程**。例外可能会被专门处理例外的代码捕获，并执行其他的操作；或者，例外可能会打断整个程序的执行，让程序强制退出。

### 没有例外处理时：

在没有例外处理的时候，如何让一个程序变得健壮呢？

通过**检查**。在每个可能出错的操作前，**检查可能出错的内容**（或者检查已进行的流程有没有问题）。比如：

```pseudocode
/**
 * 0: 成功
 * -1: 读取文件失败
 * -2： 内存不足
 * -3: 文件打开失败
 */
errorCodeType readFile(String filename){
	initalize error_code = 0;
	if (fileisopened){
		if (isenoughmemory){
		 if (readfilesuccees){
		 	readfile();
		 }
		 else{
		 	error_code = -1;
		 }
		 else{
		 	error_code = -2;
		 }
		}
		else{
			error_code = -3;
		}
	}
	return error_code;
}
```

可以看到，**例外处理的代码和主要代码混在一起**，十分的不直观。

### 有例外处理时：

Java 的例外处理允许你这么做：

```java
void readFile(String filename){
    try{
        openFile();
        allocateMemory();
        readFile();
        closeFile();
    }
    catch(OpenFileError){
        doSomething();
    }
    catch (AllocateMemory){
        doSomething();
    }
}

```

可以看到，Java 的例外处理语句允许程序员**把处理例外的代码和正常执行时的代码分离开**。

## 方法的调用栈

> 栈：一个后进先出的列表。
>
> 假设栈是一个桶，向桶内加入东西时，显然最后放入的东西在最上面；而取出时，必定先取出最上侧的东西，因此是后进先出的

当一个函数调用另一个函数时，被调函数会被放进调用栈的最后；被调函数结束前，主调函数无法执行。也就是说，同一个调用栈中，只有最上面（最后）的函数会处于正在执行的状态，其他函数都处于*挂起*状态，等待自己调用的其他方法结束。

当一个例外出现之后，如果它没有被任何调用栈中的函数处理，它会「摧毁」整个调用栈，忽略所有未完成执行的函数并立刻终止程序。在 Java 中，它在显示例外之后，还会**打印产生例外的整个调用栈**。

### 例外在调用栈中的传播

如果一个例外产生了，且它没有被捕获，这个例外就会沿着调用栈传递下去，直到它被捕获。如果一个例外沿着调用链从上到下，直到尽头也没有被处理，那么它会引发异常并**打断所有代码的执行**。被捕获之后，例外不会再沿着调用栈传播（除非你用 throw 又扔出来了）。

（以下这个例子中，假设 an_error 是一个 Checked Exception。至于什么是 Checked Exception，下一节会介绍）

在 Java 中，如果你想处理一个异常：

```java
void method1(){
    try{
        do_something();
    }
    catch (an_error){
        do_some_error_handling();
    }
}
```

如果你不想处理，也可以告诉 JVM 你的函数将会把异常沿着调用链传递：

```java
void method1() throws AnError{
    do_something(); // 假设 do_something 函数可能引发 AnError;
}
```

`throws AnError` 这个标签提醒所有调用本函数的函数，这个函数可能引发异常。调用此函数的函数也可以选择：将这个例外继续传递下去，或者自己处理掉它。

> 如果一个方法包含 throws AnError 这样的标签，那么调用它的方法要么同样声明 throws AnError，要么就必须对调用它的那段代码使用 try-catch 语句做异常处理。没有第三种选项。

## Java 例外的分类与继承树

Java 的每种例外都是用一个类表示的，引发的具体例外是一个对象。所有例外的**父类**为 `Throweable`。Throwable 下分为两个分支：

- Error（Unchecked)
- Exception

其中，Error 一般是极其严重的错误，比如 JVM 可用内存不足等错误，它们无法被捕获

Exception 一般是没那么严重的问题，比如网络套接字不足，文件打不开，部分系统资源不足之类的。这种例外**可以被捕获**。Exception 下也分为两种：

- Runtime（RuntimeException)（Unchecked）
- 非 Runtime（IOException）（Checked）

这两大阵营下又各自包含一大堆子类异常。

为什么要这么区分呢？因为 RuntimeException 下的例外**不会在编译时被检查**。也就是说，javac 编译器在**编译时不会检查这些例外是否会发生**。这种「不检查是否会发生」的例外又叫做「Unchecked Exception」。其实，Error下的例外也都属于 「Unchecked Exception」的范围内（因为就算检查到了，应用程序也解决不了这种问题）

大部分“程序员细心一点就可以规避的问题”属于 RuntimeException 这一类。比如，数组下标访问越界(IndexOutOfBoundException)；除0(ArithmeticException)；尝试访问空指针指向的东西(NullPointerException)之类的。

非 Runtime 那一阵营下的例外**会在编译时被检查**。可能产生这种例外的代码所在的函数必须声明自己对这些例外的处理态度：要么**任由它在调用链上传递**，要么**自己处理例外**。如果哪个都不选择，那这个函数不能通过编译。

其他例外的例子：IOException（打开文件时可能产生的例外）。非 RuntimeException 下的例外大多数都是无法规避的，但是确实可能产生的，比如「自己程序必需的文件被用户手贱删了」之类。

> 可能看起来有些奇怪，那些「程序员设计程序时可以避免的问题」产生的例外反而不会被 JVM 要求处理；「程序员设计程序时无法预见的问题」产生的例外会被要求处理。可能是为了增强健壮性吧……比如逼着程序员做访问文件时候的检查啥的。

### UncheckedException

这种异常可以被 try-catch 语句捕获；不过，编译器不会强制你处理这些异常。即使我手动使用 `throw` 关键字扔出了一个 `UncheckedException`，我仍然不需要在调用这个函数的函数中添加 try-catch 语句块，也不用使用 `throws` 关键字声明我这个函数可能抛出异常。

### CheckedException

对于这种「无法规避的例外」，编译器规定你需要进行选择：

- 自己处理这个例外

  使用 try…catch 语句来捕捉可能发生的错误。把可能产生这个错误的代码放在 try 语句块里，在 catch 里面编写如果发生了例外，你想要怎么处理

- 你认为调用你这个函数的其他函数应当知晓自己可能发生这个例外，并且你想要让调用你函数的函数自己处理例外

  在函数的签名中添加 throws ...（... 是这个可能发生的 CheckedException 的名字）

如果你在 main 函数里仍然摆烂，选择不处理例外，而是用 throws 仍然让上层处理，谁会处理呢？

答案是：JVM 虚拟机。JVM 虚拟机一旦接受到 main 函数跑出来的例外，就**立刻中断程序**，并打印最开始出现错误的函数所在的整个调用栈。这就会出现了一大堆报错信息…

## 例外处理的关键字

### throws

可能出现 CheckedException 的函数用来「甩锅」的关键字，在函数声明中出现。它要求任何调用此函数的函数知晓，这一函数可能抛出异常，并强制调用此函数的其他函数也选择一种例外处理方法

### try

尝试执行可能发生例外的代码。

try 语句块下必须存在至少一个 catch 或者 finally 语句块，否则将不能通过编译。

### catch

一个 catch 语句之后**仅可以接一个异常类**，用来表示想要尝试「捕获」这一类（**或者这一类的子类**）的异常。

一旦出现这一类的异常，try 语句块的执行立刻被打断，并进入对应的 catch 语句块执行代码。

当存在多个 catch 语句块的时候：最多仅有**一个 **catch 语句能够捕获例外。程序会**从上到下**检查所有 catch 语句块有没有捕获这个例外。一旦一个 catch 语句块捕获了例外，其他语句块就不可能再捕获这个例外了。

由于 catch 可以捕获 一异常类（**或者这一类的子类**），并且最多仅有**一个 **catch 语句能够捕获例外，因此，在使用多个 catch 语句的时候，**必须先写子类类型，再写父类类型**。否则，子类类型的 catch 块就永远无法匹配到例外了。

### finally

在 try 语句块执行完成后，不管出没出现了例外，都会在最后执行 finally 语句块中的语句。它当中的语句**永远都会被执行**。

这可以用来干一些「绝对必要」且不管有没有例外都要做的事情，比如关闭文件，释放网络资源之类的。

> 如果 catch 块中出现了 return 语句，finally 块会在真正返回前被执行
>
> 如果 catch 块处理例外时出现了新例外，finally 块仍然会执行

### throw

throw 语句用来**手动抛出一个例外**。

- throw 语句可以在 catch 语句块的最后使用，来重新抛出已经捕获的例外，以便让调用它的函数知道自己发生了例外

  ```java
  void method1(){
      try{
          
      } catch (ArithmeticException e){
          do_something();
          throw e;
      }
  }
  ```

- 或者，在你自己的业务逻辑中，手动抛出一个你自己的例外，让调用本函数的函数知道这个函数出了问题

## 自定义异常

如果你的自定义异常类继承自 `CheckedException` （包含 `Throwable` 类自身、 `Exception` 类以及其子类，但不包括 `RuntimeException` 与其子类），那么它是一个编译阶段需要检查的异常。

如果你的自定义异常类继承自 `UncheckedException`（包含 `Error` 类与其子类，·`RuntimeException` 类以及其子类），那么它在编译阶段不会被强制检查。

请注意：Java 当中并不是真的有两个类叫 `CheckedException` 和 `UncheckedException`这两个东西只是概念性的，我们给的定义罢了。

`CheckedException` 包含 `Exception` 类以及其子类，还有 `Throwable` 类自身，但不包括 `RuntimeException` 与其子类

 `UncheckedException`包含 `Error` 类与其子类，·`RuntimeException` 类以及其子类